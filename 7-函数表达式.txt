1、函数声明与函数表达式，区别就在于函数声明提升；
  函数表达式创建的是匿名函数，将其赋值给变量很有用；

2、实现递归函数时，用arguments.callee（一个指向正在执行函数的指针）代替函数名，防止函数赋值变量改变带来问题；
  但严格模式下，该属性不可用；  因此改用命名函数表达式，将命名函数赋值给变量；（P178）

3、闭包：有权访问另一个函数作用域中变量的函数；其实现原理基于函数的作用域链；

4、闭包与变量对象，活动对象；（待深入理解P182）

5.闭包中的this对象；this对象是在运行时基于函数的执行环境绑定的，当函数作为某个对象的方法调用时，this就等于那个对象；
 但是匿名函数(闭包内函数)的执行环境具有全局性，因此其this对象通常指向window;

6、js中没有块级作用域，语句块中的变量实际作用域是整个函数；并且多次声明变量时不会报错，会对后续声明中的变量初始化；
  匿名函数可以用于模拟块级作用域，形成私有作用域，语法：
          (function(){
             //这里是私有作用域
          })()
  function是函数声明的开始，函数声明后面不能跟圆括号，函数表达式可以；
     function(){
             
     }()//报错

7、原本函数调用完毕则会销毁作用域中的变量，由于闭包的存在，内部函数的作用域链一直保存，占用着内存；

8、私有变量指的是函数内部定义的变量，包括函数参数、局部变量、内部定义的函数，这些无法在外部访问的变量；

9、有权访问私有变量和私有函数的公有方法称为特权方法；其定义有两种方式
  一是在构造函数中定义，作为闭包访问内部变量，这种方式的缺点是针对每个实例都会创建这组方法；
  二是使用静态私有变量：在私有作用域中定义私有变量和函数，再定义一个构造函数，给其原型添加方法，
  这些方法作为闭包就可以访问私有作用域中的变量和函数了，且不必重复创建该方法；
  这样做的缺点就是私有变量变成了所有实例共享的属性和方法；

10、用字面量方式创建的对象称为单例对象，单例对象可采用模块模式添加私有变量和特权方法；（P189）

11、若要求返回的单例必须是某种类型的实例，则需要使用增强的模块模式，指定返回对象的类型；
 

闭包部分较复杂，还需要再研究。







